#!/usr/bin/env bash

# ðŸ”’ Module WireGuard - Configuration VPN serveur
# Extrait du monolithe setup.sh pour une approche modulaire

set -euo pipefail

# Source du logging
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/../logging/logger.sh"

MODULE_NAME="WIREGUARD"
log_info "$MODULE_NAME" "DÃ©but installation module WireGuard"

# Variables globales du module
WG_IF="${WG_IF:-wg0}"
WG_CONFIG_DIR="/etc/wireguard"
WG_CONFIG_FILE="$WG_CONFIG_DIR/${WG_IF}.conf"
SERVER_KEYS_DIR="$WG_CONFIG_DIR/keys"

# ====== VALIDATION DES PARAMÃˆTRES ======

validate_parameters() {
    log_step "$MODULE_NAME" "Validation des paramÃ¨tres" "1/6"
    
    # Validation domaine
    validate_or_fatal "$MODULE_NAME" "[[ -n \$DOMAIN ]]" "Domaine requis (variable DOMAIN)"
    log_debug "$MODULE_NAME" "Domaine: $DOMAIN"
    
    # Validation prÃ©fixe IPv6
    validate_or_fatal "$MODULE_NAME" "[[ -n \$IPV6_PREFIX ]]" "PrÃ©fixe IPv6 requis (variable IPV6_PREFIX)"
    if [[ ! "$IPV6_PREFIX" =~ ^[0-9a-f:]+$ ]]; then
        log_fatal "$MODULE_NAME" "Format prÃ©fixe IPv6 invalide: $IPV6_PREFIX"
    fi
    log_debug "$MODULE_NAME" "PrÃ©fixe IPv6: ${IPV6_PREFIX}::/64"
    
    # Validation port
    local port="${PORT:-51820}"
    if [[ ! "$port" =~ ^[0-9]+$ ]] || [[ $port -lt 1 || $port -gt 65535 ]]; then
        log_fatal "$MODULE_NAME" "Port invalide: $port"
    fi
    log_debug "$MODULE_NAME" "Port WireGuard: $port"
    
    # Validation interface WAN
    validate_or_fatal "$MODULE_NAME" "[[ -n \$WAN_IF ]]" "Interface WAN requise (variable WAN_IF)"
    validate_or_fatal "$MODULE_NAME" "ip link show \$WAN_IF >/dev/null 2>&1" "Interface WAN introuvable: $WAN_IF"
    log_debug "$MODULE_NAME" "Interface WAN: $WAN_IF"
    
    log_success "$MODULE_NAME" "ParamÃ¨tres validÃ©s"
}

# ====== GÃ‰NÃ‰RATION DES CLÃ‰S ======

generate_server_keys() {
    log_step "$MODULE_NAME" "GÃ©nÃ©ration des clÃ©s serveur" "2/6"
    
    # CrÃ©ation rÃ©pertoire sÃ©curisÃ© pour les clÃ©s
    if ! mkdir -p "$SERVER_KEYS_DIR" 2>/dev/null; then
        log_fatal "$MODULE_NAME" "Impossible de crÃ©er: $SERVER_KEYS_DIR"
    fi
    chmod 700 "$SERVER_KEYS_DIR"
    log_debug "$MODULE_NAME" "RÃ©pertoire clÃ©s crÃ©Ã©: $SERVER_KEYS_DIR"
    
    # Fichiers de clÃ©s
    local private_key_file="$SERVER_KEYS_DIR/server_private.key"
    local public_key_file="$SERVER_KEYS_DIR/server_public.key"
    local legacy_public_file="$WG_CONFIG_DIR/server_public.key"  # CompatibilitÃ©
    
    # GÃ©nÃ©ration uniquement si les clÃ©s n'existent pas
    if [[ -f "$private_key_file" && -f "$public_key_file" ]]; then
        log_info "$MODULE_NAME" "ClÃ©s serveur existantes dÃ©tectÃ©es - rÃ©utilisation"
        SV_PRIV=$(cat "$private_key_file")
        SV_PUB=$(cat "$public_key_file")
        log_debug "$MODULE_NAME" "ClÃ©s chargÃ©es depuis: $SERVER_KEYS_DIR"
    else
        log_info "$MODULE_NAME" "GÃ©nÃ©ration de nouvelles clÃ©s serveur..."
        
        # SÃ©curisation umask pour gÃ©nÃ©ration clÃ©s
        local old_umask=$(umask)
        umask 077
        
        # GÃ©nÃ©ration clÃ© privÃ©e
        log_debug "$MODULE_NAME" "GÃ©nÃ©ration clÃ© privÃ©e..."
        if ! SV_PRIV=$(wg genkey); then
            log_fatal "$MODULE_NAME" "Ã‰chec gÃ©nÃ©ration clÃ© privÃ©e"
        fi
        
        # GÃ©nÃ©ration clÃ© publique
        log_debug "$MODULE_NAME" "GÃ©nÃ©ration clÃ© publique..."
        if ! SV_PUB=$(echo "$SV_PRIV" | wg pubkey); then
            log_fatal "$MODULE_NAME" "Ã‰chec gÃ©nÃ©ration clÃ© publique"
        fi
        
        # Sauvegarde sÃ©curisÃ©e
        if ! echo "$SV_PRIV" > "$private_key_file"; then
            log_fatal "$MODULE_NAME" "Impossible de sauvegarder clÃ© privÃ©e"
        fi
        
        if ! echo "$SV_PUB" > "$public_key_file"; then
            log_fatal "$MODULE_NAME" "Impossible de sauvegarder clÃ© publique"
        fi
        
        # CompatibilitÃ© avec ancien systÃ¨me
        echo "$SV_PUB" > "$legacy_public_file"
        
        # Permissions restrictives
        chmod 600 "$private_key_file"
        chmod 644 "$public_key_file" "$legacy_public_file"
        
        # Restauration umask
        umask "$old_umask"
        
        log_success "$MODULE_NAME" "Nouvelles clÃ©s gÃ©nÃ©rÃ©es et sauvegardÃ©es"
        log_debug "$MODULE_NAME" "ClÃ© publique: ${SV_PUB:0:20}..."
    fi
    
    # Export des variables pour autres Ã©tapes
    export SV_PRIV SV_PUB
}

# ====== GÃ‰NÃ‰RATION DE LA CONFIGURATION ======

generate_wireguard_config() {
    log_step "$MODULE_NAME" "GÃ©nÃ©ration configuration WireGuard" "3/6"
    
    local port="${PORT:-51820}"
    log_info "$MODULE_NAME" "Configuration pour interface $WG_IF (port $port)"
    
    # GÃ©nÃ©ration de la configuration optimisÃ©e Debian 12
    log_debug "$MODULE_NAME" "Ã‰criture: $WG_CONFIG_FILE"
    
    cat > "$WG_CONFIG_FILE" << EOF
# Configuration WireGuard Serveur - Boxion Tunnel VPN
# GÃ©nÃ©rÃ©e automatiquement le $(date)
# Interface: $WG_IF, Port: $port, Domaine: $DOMAIN

[Interface]
# ClÃ© privÃ©e serveur (gardÃ©e secrÃ¨te)
PrivateKey = $SV_PRIV

# Adresse IPv6 serveur (::1 = gateway du rÃ©seau)
Address = ${IPV6_PREFIX}::1/64

# Port d'Ã©coute UDP
ListenPort = $port

# SÃ‰CURITÃ‰: SaveConfig dÃ©sactivÃ© (gestion via API uniquement)
SaveConfig = false

# PostUp: Configuration rÃ©seau automatique au dÃ©marrage
PostUp = sysctl -w net.ipv6.conf.all.forwarding=1
PostUp = sysctl -w net.ipv6.conf.$WAN_IF.proxy_ndp=1
PostUp = ip6tables -I FORWARD -i %i -j ACCEPT || true
PostUp = ip6tables -I FORWARD -o %i -j ACCEPT || true

# PreDown: Nettoyage rÃ¨gles au shutdown
PreDown = ip6tables -D FORWARD -i %i -j ACCEPT || true
PreDown = ip6tables -D FORWARD -o %i -j ACCEPT || true

# Les peers seront ajoutÃ©s dynamiquement via l'API
# Configuration peer management: API REST + SQLite + scripts sudo

EOF

    # Validation fichier gÃ©nÃ©rÃ©
    if [[ ! -f "$WG_CONFIG_FILE" ]]; then
        log_fatal "$MODULE_NAME" "Configuration non crÃ©Ã©e: $WG_CONFIG_FILE"
    fi
    
    # VÃ©rification syntaxe
    local config_lines=$(wc -l < "$WG_CONFIG_FILE")
    if [[ $config_lines -lt 10 ]]; then
        log_fatal "$MODULE_NAME" "Configuration trop courte ($config_lines lignes) - gÃ©nÃ©ration Ã©chouÃ©e"
    fi
    
    # Permissions sÃ©curisÃ©es
    chmod 600 "$WG_CONFIG_FILE"
    chown root:root "$WG_CONFIG_FILE"
    
    log_success "$MODULE_NAME" "Configuration gÃ©nÃ©rÃ©e ($config_lines lignes)"
    log_debug "$MODULE_NAME" "Interface: $WG_IF â†’ ${IPV6_PREFIX}::1/64"
}

# ====== ACTIVATION DU SERVICE ======

enable_wireguard_service() {
    log_step "$MODULE_NAME" "Activation service WireGuard" "4/6"
    
    local service_name="wg-quick@$WG_IF"
    log_info "$MODULE_NAME" "Configuration du service: $service_name"
    
    # Validation de la configuration avant activation
    log_debug "$MODULE_NAME" "Validation syntaxe configuration..."
    if ! wg-quick strip "$WG_IF" >/dev/null 2>/tmp/wg-validation.log; then
        log_error_context "$MODULE_NAME" "Configuration WireGuard invalide" "$(cat /tmp/wg-validation.log)"
        rm -f /tmp/wg-validation.log
        return 1
    fi
    log_debug "$MODULE_NAME" "Configuration validÃ©e"
    
    # ArrÃªt du service s'il est dÃ©jÃ  actif (pour reconfiguration)
    if systemctl is-active "$service_name" >/dev/null 2>&1; then
        log_info "$MODULE_NAME" "Service dÃ©jÃ  actif - redÃ©marrage..."
        if ! systemctl stop "$service_name" 2>/tmp/systemctl-stop.log; then
            log_error_context "$MODULE_NAME" "Ã‰chec arrÃªt service" "$(cat /tmp/systemctl-stop.log)"
        fi
        sleep 2  # Attente pour libÃ©ration interface
    fi
    
    # Activation du service
    log_info "$MODULE_NAME" "DÃ©marrage du service WireGuard..."
    if ! systemctl start "$service_name" 2>/tmp/systemctl-start.log; then
        log_error_context "$MODULE_NAME" "Ã‰chec dÃ©marrage service" "$(cat /tmp/systemctl-start.log)"
        
        # Debug supplÃ©mentaire
        log_debug "$MODULE_NAME" "Statut interface avant Ã©chec:"
        ip link show "$WG_IF" 2>/dev/null | head -1 || log_debug "$MODULE_NAME" "Interface $WG_IF inexistante"
        
        rm -f /tmp/systemctl-*.log
        return 1
    fi
    
    # Activation au boot
    if ! systemctl enable "$service_name" 2>/dev/null; then
        log_warn "$MODULE_NAME" "Impossible d'activer au boot - service fonctionnel"
    else
        log_debug "$MODULE_NAME" "Service activÃ© au boot"
    fi
    
    # Attente stabilisation
    sleep 3
    
    # Validation du service actif
    if ! systemctl is-active "$service_name" >/dev/null 2>&1; then
        log_fatal "$MODULE_NAME" "Service non actif aprÃ¨s dÃ©marrage"
    fi
    
    log_success "$MODULE_NAME" "Service WireGuard actif"
    
    # Nettoyage logs temporaires
    rm -f /tmp/systemctl-*.log /tmp/wg-validation.log
}

# ====== VALIDATION DE L'INTERFACE ======

validate_wireguard_interface() {
    log_step "$MODULE_NAME" "Validation interface WireGuard" "5/6"
    
    # VÃ©rification existence interface
    if ! ip link show "$WG_IF" >/dev/null 2>&1; then
        log_fatal "$MODULE_NAME" "Interface $WG_IF non crÃ©Ã©e"
    fi
    log_debug "$MODULE_NAME" "Interface $WG_IF dÃ©tectÃ©e"
    
    # VÃ©rification configuration active
    if ! wg show "$WG_IF" >/dev/null 2>&1; then
        log_fatal "$MODULE_NAME" "Configuration WireGuard non active sur $WG_IF"
    fi
    
    # RÃ©cupÃ©ration informations interface
    local interface_info=$(wg show "$WG_IF" 2>/dev/null)
    local listening_port=$(echo "$interface_info" | grep "listening port:" | awk '{print $3}')
    local public_key=$(echo "$interface_info" | grep "public key:" | awk '{print $3}')
    
    # Validation port d'Ã©coute
    local expected_port="${PORT:-51820}"
    if [[ "$listening_port" != "$expected_port" ]]; then
        log_error "$MODULE_NAME" "Port incorrect: $listening_port (attendu: $expected_port)"
        return 1
    fi
    log_debug "$MODULE_NAME" "Port d'Ã©coute: $listening_port"
    
    # Validation clÃ© publique
    if [[ -z "$public_key" ]]; then
        log_error "$MODULE_NAME" "ClÃ© publique non dÃ©tectÃ©e sur l'interface"
        return 1
    fi
    
    if [[ "$public_key" != "$SV_PUB" ]]; then
        log_error "$MODULE_NAME" "ClÃ© publique diffÃ©rente de celle gÃ©nÃ©rÃ©e"
        return 1
    fi
    log_debug "$MODULE_NAME" "ClÃ© publique: ${public_key:0:20}..."
    
    # VÃ©rification adresse IPv6
    local ipv6_addr=$(ip -6 addr show "$WG_IF" | grep "inet6" | grep -v "fe80" | awk '{print $2}')
    local expected_addr="${IPV6_PREFIX}::1/64"
    
    if [[ "$ipv6_addr" != "$expected_addr" ]]; then
        log_warn "$MODULE_NAME" "Adresse IPv6 diffÃ©rente: $ipv6_addr (attendue: $expected_addr)"
    else
        log_debug "$MODULE_NAME" "Adresse IPv6: $ipv6_addr"
    fi
    
    log_success "$MODULE_NAME" "Interface WireGuard validÃ©e"
}

# ====== TEST DE CONNECTIVITÃ‰ ======

test_wireguard_connectivity() {
    log_step "$MODULE_NAME" "Tests de connectivitÃ©" "6/6"
    
    # Test ping local sur l'interface
    local gateway_ip="${IPV6_PREFIX}::1"
    log_debug "$MODULE_NAME" "Test ping local: $gateway_ip"
    
    if ping6 -c 1 -W 2 "$gateway_ip" >/dev/null 2>&1; then
        log_success "$MODULE_NAME" "Ping local IPv6 rÃ©ussi"
    else
        log_warn "$MODULE_NAME" "Ping local IPv6 Ã©chouÃ© - peut Ãªtre normal"
    fi
    
    # Test rÃ©solution DNS (si disponible)
    if command -v nslookup >/dev/null 2>&1; then
        log_debug "$MODULE_NAME" "Test rÃ©solution DNS..."
        if nslookup "$DOMAIN" >/dev/null 2>&1; then
            log_debug "$MODULE_NAME" "RÃ©solution DNS fonctionnelle: $DOMAIN"
        else
            log_warn "$MODULE_NAME" "RÃ©solution DNS Ã©chouÃ©e: $DOMAIN"
        fi
    fi
    
    # Statistiques finales
    local peer_count=$(wg show "$WG_IF" peers | wc -l)
    log_info "$MODULE_NAME" "Interface configurÃ©e - $peer_count peer(s) connectÃ©(s)"
    
    log_success "$MODULE_NAME" "Tests de connectivitÃ© terminÃ©s"
}

# ====== AFFICHAGE DES INFORMATIONS ======

display_wireguard_info() {
    log_info "$MODULE_NAME" "=== INFORMATIONS WIREGUARD ==="
    log_info "$MODULE_NAME" "Interface: $WG_IF"
    log_info "$MODULE_NAME" "Port: ${PORT:-51820}"
    log_info "$MODULE_NAME" "Domaine: $DOMAIN"
    log_info "$MODULE_NAME" "IPv6 Gateway: ${IPV6_PREFIX}::1/64"
    log_info "$MODULE_NAME" "ClÃ© publique: $SV_PUB"
    log_info "$MODULE_NAME" "Service: $(systemctl is-active "wg-quick@$WG_IF")"
    
    # Export des variables importantes pour autres modules
    echo "export SV_PUB='$SV_PUB'" > /tmp/boxion-wireguard-vars.sh
    echo "export WG_IF='$WG_IF'" >> /tmp/boxion-wireguard-vars.sh
    echo "export IPV6_PREFIX='$IPV6_PREFIX'" >> /tmp/boxion-wireguard-vars.sh
    
    log_debug "$MODULE_NAME" "Variables exportÃ©es: /tmp/boxion-wireguard-vars.sh"
}

# ====== MAIN MODULE ======

main() {
    log_info "$MODULE_NAME" "=== INSTALLATION MODULE WIREGUARD ==="
    
    # VÃ©rification privilÃ¨ges root
    if [[ $UID -ne 0 ]]; then
        log_fatal "$MODULE_NAME" "PrivilÃ¨ges root requis"
    fi
    
    # SÃ©quence d'installation WireGuard
    validate_parameters
    generate_server_keys
    generate_wireguard_config
    enable_wireguard_service
    validate_wireguard_interface
    test_wireguard_connectivity
    display_wireguard_info
    
    log_success "$MODULE_NAME" "Module WireGuard installÃ© avec succÃ¨s!"
    return 0
}

# ExÃ©cution si appelÃ© directement
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
